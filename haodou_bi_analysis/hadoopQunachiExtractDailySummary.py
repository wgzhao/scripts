# -*- coding: UTF-8 -*- #coding = utf-8#去哪吃数据收集统计from optparse import OptionParserimport commandsimport threadingfrom time import ctimefrom MailUtil import *from DBUtil import *from XLSWriter import XLSWriterfrom hiveDB import *from timeUtils import *import tracebackimport picklefrom  datetime  import  *import csv, codecsimport timeimport sysimport osimport reclass DailyBeforeUpdateThread(threading.Thread):	def __init__(self, sinal=None, skipLoad=0, delay=1):		threading.Thread.__init__(self,name='DailyBeforeUpdateThread')		self.sinal = sinal		self.delay = delay		self.db = DB()		self.skipLoad = skipLoad		dt = datetime.now()		self._datetime = dt - timedelta(days = delay)		self.hive = hiveDB()						self.yesterdayMap = {}		self.weekMap = {}		self.monthMap = {}				self.newUsersWeekMap = {}		self.newUsersMonthMap = {}		self.tu = TimeUtils()			def run(self):				if self.skipLoad == 0:						printLog("查往期的渠道和设备列表")						#取经过计算的起始时间作为初始参数			#t = time.time()			#virtual_datetime = self._datetime - timedelta(days = 1)			virtual_datetime = self._datetime			t = time.mktime(virtual_datetime.timetuple())						#判断如果还未到自然周第一日则不做计算			#判断如果已经到了自然周第一日则			#1.取出上上周的新增用户			#2.取出上周的活跃用户			printLog("判断当前时间是否在每周一")			nowDate = virtual_datetime.strftime('%Y-%m-%d')			#算本周一			nowWeekDate = time.strftime('%Y-%m-%d',time.localtime(self.tu.get_week_begin(t)))			if nowWeekDate == nowDate:			#if True:				printLog("当前时间%s是在本周一"%nowDate)				printLog("生成上周活跃用户渠道-设备号列表")				self.weekMap = {}				self.prepareForPerDate(nowWeekDate,t,'w',self.weekMap)								#获得上周起始时间				startDate = time.strftime('%Y-%m-%d',time.localtime(self.tu.get_week_begin(t,-1)))				printLog("生成上上周新用户渠道-设备号列表")				self.newUsersWeekMap = {}				self.prepareForNewUserDate(startDate,t,'w',self.newUsersWeekMap)						#判断如果还未到自然月第一日则不做计算			#判断如果已经到了自然月第一日则			#1.取出上上月的新增用户			#2.取出上月的活跃用户			printLog("判断当前时间是否在每月一号")			#算本周一			nowMonthDate = time.strftime('%Y-%m-%d',time.localtime(self.tu.get_month_begin(t)))			if nowMonthDate == nowDate:						#if True:					printLog("当前时间%s是在本月第一天"%nowDate)				printLog("生成上月活跃用户渠道-设备号列表")				self.monthMap = {}				self.prepareForPerDate(nowMonthDate,t,'m',self.monthMap)								#获得上月起始时间				startDate = time.strftime('%Y-%m-%d',time.localtime(self.tu.get_month_begin(t,-1)))				printLog("生成上上月新用户渠道-设备号列表")				self.newUsersMonthMap = {}				self.prepareForNewUserDate(startDate,t,'m',self.newUsersMonthMap)						self.sinal.set()				#只允许跳过一次		self.skipLoad = 0		#查新用户渠道和设备列表	def prepareForNewUserDate(self, startDate, t, flag, maps):		#1.根据标志以起点时间推上上周(上上月)结束时间		#2.根据标志获取上上周(上上月)起始时间		#3.根据起始时间结束时间在first_day取新增用户渠道和设备列表		max_date = (datetime.strptime(startDate,'%Y-%m-%d') - timedelta(days = 1)).strftime("%Y-%m-%d")		min_date = startDate		if flag == 'w':			min_date = time.strftime('%Y-%m-%d',time.localtime(self.tu.get_week_begin(t,-2)))		elif flag == 'm':			min_date = time.strftime('%Y-%m-%d',time.localtime(self.tu.get_month_begin(t,-2)))				printLog("生成 %s 到 %s 的新用户渠道-设备号列表"%(min_date,max_date))					sql = "select concat(channel,'_v',version) as channel,upper(device_id) from bi_app_device_qunachi where (appid=1 or appid=3) and first_day between '%s' and '%s'"		print sql%(min_date,max_date)				cursor = self.db.execute(sql%(min_date,max_date))						for row in cursor:			chl = row[0]			device = row[1]						if chl not in maps:				maps[chl] = {}			maps[chl][device] = device			#查单独的渠道和设备列表	def prepareForPerDate(self, startDate, t, flag, maps):		#1.根据标志以起点时间推上周(上月)结束时间		#2.根据标志获取上周(上月)起始时间		#3.根据起始时间结束时间取用户渠道和设备列表		max_date = (datetime.strptime(startDate,'%Y-%m-%d') - timedelta(days = 1)).strftime("%Y-%m-%d")		min_date = startDate		if flag == 'w':			min_date = time.strftime('%Y-%m-%d',time.localtime(self.tu.get_week_begin(t,-1)))		elif flag == 'm':			min_date = time.strftime('%Y-%m-%d',time.localtime(self.tu.get_month_begin(t,-1)))				sql = "SELECT channel_id,upper(device_id) from logs.log_php_app_log WHERE logdate between '%s' and '%s' and (appid=3 or appid=1) group by channel_id,device_id"		print sql%(min_date,max_date)				printLog("生成 %s 到 %s 的渠道-设备号列表"%(min_date,max_date))						cursor = self.hive.execute(sql%(min_date,max_date))				for cols in cursor:			row = re.split(r"\s+",cols)			channel = str(row[0])			device = str(row[1])			if device.strip() != '' and channel.strip() != '':				if channel not in maps:					maps[channel] = {}				maps[channel][device] = 0				def destroy(self):				self.monthMap = {}		self.weekMap = {}		self.newUsersWeekMap = {}		self.newUsersMonthMap = {}		def getMonthMap(self):		return self.monthMap			def getWeekMap(self):		return self.weekMap			def getNewUsersWeekMap(self):		return self.newUsersWeekMap		def getNewUsersMonthMap(self):		return self.newUsersMonthMapclass DailyAfterUpdateThread(threading.Thread):	def __init__(self, ma=None, event=None, delay=1):		threading.Thread.__init__(self,name='DailyAfterUpdateThread')		self.ma = ma		self.threadEvent = event		self.delay = delay		self.db = DB()		self.db.execute("set autocommit = 1")		#错误日志邮件发送		self.errorMail = MailSender()				dt = datetime.now()		self._datetime = dt - timedelta(days = self.delay)		self.curDate = self._datetime.strftime("%Y-%m-%d")				def destroy(self):		self.ma.destroy()			def run(self):				self.threadEvent.wait()				#----后台更新代码----		self.update()				#清空内存占用		self.destroy()				self.threadEvent.clear()		#和后台数据库同步基础数据	def update(self):				printLog("开始自动和后台数据库同步基础数据")				#清空原始数据		printLog("清空原始数据")		sql = "delete from bi_app_device_startup where create_time = '%s' and (appid=3 or appid=1)"		try:			self.db.execute(sql%(self.curDate))			print sql%(self.curDate)		except Exception:			printLog("删除失败！")						traceback.print_exc()			self.db.close()				#增量更新用户启动APP次数与时段分布		printLog("增量更新用户启动APP次数与时段分布")		sql = "INSERT INTO bi_app_device_startup (channel,startup,time_area,appid,create_time) VALUES ('%s','%s','%s','%s','%s')"				timeArea = self.ma.getTimeArea()		for channel in timeArea.keys():			for appid in timeArea[channel].keys():				for area in timeArea[channel][appid].keys():					area_count = timeArea[channel][appid][area]					try:								self.db.execute(sql%(channel,area_count,area,appid,self.curDate))					except Exception:						printLog("insert error!")						printLog(sql%(channel,area_count,area,appid,self.curDate))						traceback.print_exc()						continue				printLog("增量更新老用户表")		printLog("今日新增用户 " + str(len(self.ma.getNewUsers())))		printLog("清空原始数据")		self.db.execute("DELETE FROM bi_app_device_qunachi where first_day ='%s'"%self.curDate)				#增量更新老用户表		increcipe = "INSERT INTO bi_app_device_qunachi (device_id,os_type,first_day,appid,user_id,userip,channel,version,create_date,ios_idfa,ios_idfv) "		increcipe = increcipe + " VALUES ('%s', '%s', '%s', '%s', '%s', '%s', '%s', '%s', '%s', '%s', '%s');"				for device in self.ma.getNewUsers().keys():			user = self.ma.getNewUsers()[device]			try:						self.db.execute(increcipe%(user['deviceid'],user['os'],user['firstDay'],user['appid'],user['userId'],user['userIp'],user['pag'],user['var'],user['date'],user['idfa'],user['idfv']))			except Exception:				printLog("insert error!")				errorMsg = "增量更新老用户表 错误\n"				errorMsg += "sql语句: " + increcipe%(user['deviceid'],user['os'],user['firstDay'],user['appid'],user['userId'],user['userIp'],user['pag'],user['var'],user['date'],user['idfa'],user['idfv'])								printLog(errorMsg)								traceback.print_exc()				continue				printLog("更新结束")		ms = MailSender()		#ms.sendMail("zhaoweiguo@haodou.com", "去哪吃渠道统计监控", "增量更新用户启动APP次数与时段分布、增量更新老用户表都已更新结束")				self.db.close()					class QunachiExtractDailySummary(threading.Thread):		def __init__(self, before=None, fpath="", beforEvent=None, sinal=None, delay=1):		threading.Thread.__init__(self,name='QunachiExtractDailySummary')		self.db = DB()		self.db.execute("set autocommit = 1")		self.threadEvent = beforEvent		self.hive = hiveDB()		self.delay = delay		dt = datetime.now()		self._datetime = dt - timedelta(days = delay)		self.curDate = self._datetime.strftime("%Y%m%d")				self.sinal = sinal		self.before = before				self.timeArea = {}		self.newusers = {}		self.newUsersInfo = {}		self.biAppChannelAnalysis = []		self.oldQunachiDevices = {}						#错误日志邮件发送		self.errorMail = MailSender()				self.file_path = fpath + "/" + self._datetime.strftime("%Y%m") + "/%s"				if os.path.isdir(fpath + "/" + self._datetime.strftime("%Y%m")) is False:			os.mkdir(fpath + "/" + self._datetime.strftime("%Y%m"))		def getNewUsers(self):		return self.newUsersInfo		def getTimeArea(self):		return self.timeArea		def splitChannelName(self, channel):		#包号		pag = ""		#版本号		ver = ""		p = re.compile('^(\w*)_v(\w*)$')		if p.match(channel) is not None:			ls = p.findall(channel)			pag = ls[0][0]			ver = ls[0][1]					return (pag, ver)		#销毁内存占用	def destroy(self):		self.biAppChannelAnalysis = []		self.newusers = {}		self.newUsersInfo = {}		self.timeArea = {}		self.oldQunachiDevices = {}			#主方法	def run(self):				self.threadEvent.wait()				printLog("Now time is %s"%self.curDate)				#统计原始数据		self.startCount()				#统计明细		self.statisticSummary()		problem = "渠道推广数据"				html = """\		<html>				<head></head>				<body>				%s				</body>		</html>		"""				#发邮件		printLog("发邮件")		ms = MailSender(self.file_path%("channel_qunachi_"+self.curDate+".xls"), "channel_qunachi_"+self.curDate+".xls")		#ms.sendMail("zhaoweiguo@haodou.com", "去哪吃渠道推广%s质量反馈"%self.curDate, html%problem)		#ms.sendMail("changzheng@haodou.com", "去哪吃渠道推广%s质量反馈"%self.curDate, html%problem)				#清空内存占用		self.before.destroy()				self.threadEvent.clear()				self.sinal.set()		def getPersistentData(self, topic):		regex_getMap = "(?P<method>get):(?P<key>.+?Map):(?P<date>[0-9]{4}-[0-9]{1,2}-[0-9]{1,2})"		m = re.findall(regex_getMap,topic)		for (method, key, date) in m:			if method == "get":				filename = self.file_path%(topic.replace(":","_").strip() + ".txt")								if os.path.exists(filename):					printLog(filename + ' 取文件...')					files=open(filename)					value = ""					for chunk in files:						value += chunk					stuff = pickle.loads(value.strip())					return stuff				else:					value = {}					return value		#统计全部的启动次数 单次使用时长 新用户数	def startCount(self):				date = self._datetime.strftime("%Y-%m-%d")				sql = "select request_time,upper(device_id),channel_id,userip,appid,userid from logs.log_php_app_log where logdate='%s' and (appid=3 or appid=1) order by request_time"		cursor = self.hive.execute(sql%(date))				rowlist = {}					totalCount = 0		totalUseTime = 0				consUseTime = 5*60				#用户启动APP次数与时段分布		self.timeArea = {}		p = re.compile('^(\w*)_v(\w*)$')		for cols in cursor:			try:				row = re.split(r"\s+",cols)				if len(row) != 6:								continue									chl = row[2]								#校验渠道号格式				m = p.findall(chl)				if not m:					continue									dv = row[1]				et = int(row[0])				appid = row[4]								et = datetime.fromtimestamp(et)								if chl is None:					key = str(dv)				else:					key = str(dv) + "_" + chl								if key not in rowlist:					rowlist[key] = {}										if chl == "appstore":						rowlist[key]['os'] = "ios"					else:						rowlist[key]['os'] = "android"												rowlist[key]['appid'] = appid					rowlist[key]['device'] = str(dv)					rowlist[key]['channel'] = str(chl)					rowlist[key]['count'] = 1					rowlist[key]['endTime'] = et					rowlist[key]['useTime'] = 0					rowlist[key]['firstDay'] = et					rowlist[key]['userId'] = row[5]					rowlist[key]['userIp'] = row[3]										totalCount += 1										nowTime = et.strftime("%Y-%m-%d %H") + ":00:00"					if chl not in self.timeArea:						self.timeArea[chl] = {}						if appid not in self.timeArea[chl]:							self.timeArea[chl][appid] = {}		
					if nowTime not in self.timeArea[chl][appid]:								self.timeArea[chl][appid][nowTime] = 1											elif (et-rowlist[key]['endTime']).seconds>consUseTime:											rowlist[key]['count'] += 1					totalCount += 1										rowlist[key]['endTime'] = et										nowTime = et.strftime("%Y-%m-%d %H") + ":00:00"					if chl in self.timeArea:						if appid in self.timeArea[chl]:							if nowTime in self.timeArea[chl][appid]:								self.timeArea[chl][appid][nowTime] += 1															elif (et-rowlist[key]['endTime']).seconds<=consUseTime:											singleUseTime = (et-rowlist[key]['endTime']).seconds					rowlist[key]['useTime'] += singleUseTime					totalUseTime += singleUseTime										rowlist[key]['endTime'] = et								except Exception:				printLog("calculate error!")				errorMsg = "启动次数 单次使用时长统计 错误<br />"				errorMsg += "错误数据：" + cols							printLog(errorMsg)				traceback.print_exc()				continue				printLog(len(self.timeArea))		printLog(totalCount)		printLog(int(totalUseTime/totalCount))						#新用户数统计		self.newusers = {}		self.newUsersInfo = {}				printLog("新用户数统计")		self.oldQunachiDevices = {}		printLog("获取去哪吃老用户设备号")		cursor = self.db.execute("SELECT upper(device_id) FROM bi_app_device_qunachi where date(first_day) <'%s'"%date)		for row in cursor:			deviceid = ""			if isinstance(row[0], str) == False:				deviceid = row[0].encode('utf-8')			else:				deviceid = str(row[0])			self.oldQunachiDevices[deviceid] = 0				"""		while True:			oldQunachiDevices = self.getPersistentData("get:oldQunachiDevicesMap:" + date)			if len(oldQunachiDevices) == 0:				printLog("数据没有生成，等待中...")				time.sleep(10)				continue			else:				break		"""				printLog("启动次数 单次使用时长统计 新用户")		for key in rowlist.keys():			channel = rowlist[key]['channel']									spName = self.splitChannelName(channel)						deviceid = rowlist[key]['device']			rs = deviceid.split('|')			idfa = ""			idfv = ""			if len(rs)>=2:				idfa = rs[1].upper().strip()				if len(rs)==3:					idfv = rs[2].upper().strip()								deviceid = rs[0]						item = {}			item[0] = self.curDate			item[1] = rowlist[key]['device']			item[2] = rowlist[key]['userIp']			item[3] = rowlist[key]['channel']			item[4] = rowlist[key]['count']			item[5] = rowlist[key]['useTime']			item[6] = rowlist[key]['appid']						self.biAppChannelAnalysis.append(item)						#--1:去哪吃iphone/2:菜谱安卓/3:去哪吃安卓/4:菜谱iphone/5:华为机顶盒/6:菜谱ipad			try:				if deviceid not in self.oldQunachiDevices:										if deviceid not in self.newUsersInfo:							self.newUsersInfo[deviceid] = {}							self.newUsersInfo[deviceid]['deviceid'] = deviceid							self.newUsersInfo[deviceid]['os'] = rowlist[key]['os']							self.newUsersInfo[deviceid]['firstDay'] = rowlist[key]['firstDay']							self.newUsersInfo[deviceid]['appid'] = int(rowlist[key]['appid'])							self.newUsersInfo[deviceid]['userId'] = rowlist[key]['userId']							self.newUsersInfo[deviceid]['userIp'] = rowlist[key]['userIp']							self.newUsersInfo[deviceid]['pag'] = spName[0]							self.newUsersInfo[deviceid]['var'] = spName[1]							self.newUsersInfo[deviceid]['date'] = date							self.newUsersInfo[deviceid]['idfa'] = idfa							self.newUsersInfo[deviceid]['idfv'] = idfv																firstTime = rowlist[key]['firstDay'].strftime("%H") + ":00:00"										#统计新用户在小时时段内的数量					if channel not in self.newusers:						self.newusers[channel] = {}						self.newusers[channel]['count'] = 1												if firstTime not in self.newusers[channel]:						self.newusers[channel][firstTime] = 1					else:						self.newusers[channel][firstTime] += 1						self.newusers[channel]['count'] += 1															self.oldQunachiDevices[deviceid] = 0								except Exception:				printLog("insert error!")				errorMsg = "启动次数 单次使用时长 新用户统计 错误<br />"				errorMsg += self.curDate + " " + rowlist[key]['device'] + " " + rowlist[key]['userIp'] + " " + rowlist[key]['channel'] + " " + rowlist[key]['count'] + " " + rowlist[key]['useTime'] + " " + rowlist[key]['appid']							printLog(errorMsg)				traceback.print_exc()				continue						print len(self.newUsersInfo)			"""			#统计总设备数		printLog("清空旧数据")		sql = "delete from bi_app_device_qunachi_increment where date(create_time) = '%s'"		self.db.execute(sql%(date))				printLog("统计总设备数")		totalUserCount = len(oldQunachiDevices) + len(self.newUsersInfo)				sql = "INSERT INTO bi_app_device_qunachi_increment (newuser_count,create_time) VALUES ('%s','%s')"		self.db.execute(sql%(totalUserCount,date))				"""	#查今日的渠道和设备列表	def prepareForNowDate(self, maps, appid):				sql = "SELECT channel_id,upper(device_id) from logs.log_php_app_log WHERE logdate='%s' and %s group by channel_id,device_id"				day = self._datetime.strftime("%Y-%m-%d")		printLog("生成 %s 的渠道-设备号列表"%day)				cursor = self.hive.execute(sql%(day,appid))				for cols in cursor:			row = re.split(r"\s+",cols)			channel = str(row[0])			device = str(row[1])			if device.strip() != '' and channel.strip() != '':				if channel not in maps:					maps[channel] = {}					maps[channel][delay] = []				elif delay not in maps[channel]:					maps[channel][delay] = []										maps[channel][device] = device				#未来需要按每IP获取设备数用以计算日活				maps[channel][delay].append(device)								def statisticSummary(self):				today = self._datetime.strftime("%Y-%m-%d")			channels = {}				for row in self.biAppChannelAnalysis:			channel = str(row[3])			if channel not in channels:				channels[channel] = {}				#使用时长				channels[channel]['use_time'] = int(row[5])				#启动次数				channels[channel]['startup'] = int(row[4])				#设备列表				channels[channel]['devices'] = []				channels[channel]['devices'].append(str(row[1]))								#活跃用户数					channels[channel]['active_user'] = 1			else:									channels[channel]['use_time'] += int(row[5])						channels[channel]['active_user'] += 1				channels[channel]['startup'] += int(row[4])						channels[channel]['devices'].append(str(row[1]))			channels[channel]['appid'] = str(row[6])														insertSql = "INSERT INTO bi_app_channel_summary (request_time,channel,new_user,increment_time,startup,use_time,active_user,seven_active_user,thirty_active_user,survival_probability,seven_survival_probability,thirty_survival_probability,uninstall,appid,active_register_count) "		insertSql = insertSql + "VALUES ('%s','%s',%s,'%s',%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s)"				#写文件		xlswriter = XLSWriter(self.file_path%("channel_qunachi_"+self.curDate+".xls"))				xlswriter.writerow(["日期","当日新增用户","当日增量最多时间","包号","版本","昨日活跃用户","周活跃用户","月活跃用户","次日留存率","周留存率","月留存率","启动次数","单次使用时长"], sheet_name=u'渠道信息')						printLog("清空旧的原始数据")		self.db.execute("DELETE FROM bi_app_channel_summary WHERE request_time='%s 00:00:00' and (appid=3 or appid=1)"%today)				printLog("生成昨日渠道明细表")				#取得昨日新增用户		yesterday = (self._datetime - timedelta(days = 1)).strftime("%Y-%m-%d")		printLog("生成 %s 的新增用户渠道-设备列表"%yesterday)				sql = "select concat(channel,'_v',version) as channel,upper(device_id) from bi_app_device_qunachi where (appid=1 or appid=3) and first_day='%s'"		cursor = self.db.execute(sql%yesterday)		print sql%yesterday				yesterdayNewUsers = {}		for row in cursor:			chl = row[0]			device = row[1]			if chl not in yesterdayNewUsers:				yesterdayNewUsers[chl] = {}			yesterdayNewUsers[chl][device] = device				yesterdayMap = {}		self.prepareForNowDate(yesterdayMap, "(appid = 1 or appid = 3)")				printLog("获取活跃的注册用户数")		#获取活跃的注册用户数(分渠道)		#出现一次即算一个数		for channel in yesterdayMap.keys():			for device in yesterdayMap[channel]:				if device in self.oldQunachiDevices:					if channel in channels:						if 'active_register_count' not in channels[channel]:							channels[channel]['active_register_count'] = 0						channels[channel]['active_register_count'] += 1				"""				while True:			yesterdayMap = self.getPersistentData("get:qunachi:yesterdayMap:" + today)			if len(yesterdayMap) == 0:				printLog("数据没有生成，等待中...")				time.sleep(10)				continue			else:				break		while True:			weekMap = self.getPersistentData("get:qunachi:weekMap:" + today)			if len(weekMap) == 0:				printLog("数据没有生成，等待中...")				time.sleep(10)				continue			else:				break		while True:			monthMap = self.getPersistentData("get:qunachi:monthMap:" + today)			if len(monthMap) == 0:				printLog("数据没有生成，等待中...")				time.sleep(10)				continue			else:				break		"""		weekMap = self.before.getWeekMap()		monthMap = self.before.getMonthMap()		newUsersWeekMap = self.before.getNewUsersWeekMap()		newUsersMonthMap = self.before.getNewUsersMonthMap()						for channel in channels:						spName = self.splitChannelName(channel)								#应用ID			appid = channels[channel]['appid']								startup = channels[channel]['startup']			use_time = channels[channel]['use_time']						#昨日活跃用户数			active_user = channels[channel]['active_user']						#当日新增用户数			new_user = 0			if channel in self.newusers:				new_user = self.newusers[channel]['count']						#当日增量最多时间			increment_time = "00:00:00"			increment_time_count = 0						if channel in self.newusers:				for c_t in self.newusers[channel].keys():					if c_t != "count":						if increment_time_count <= self.newusers[channel][c_t]:							increment_time_count = self.newusers[channel][c_t]							increment_time = c_t												#周活跃用户率 			min_active_user = 0			if channel in weekMap:				min_active_user = len(weekMap[channel])			if min_active_user >0:				min_active_user = round(float(active_user)/float(active_user + min_active_user)*100,2)								#月活跃用户率			max_active_user = 0			if channel in monthMap:				max_active_user = len(monthMap[channel])			if max_active_user >0:				max_active_user = round(float(active_user)/float(active_user + max_active_user)*100,2)									#次日渠道留存率			#次日留存率=当日新增用户数在次日启动了APP至少1次的用户数/当日新增用户数			#1.取得昨日新增用户			#2.取得当日启动用户			#3.比较 取今日留存数			sp = 0.0			if channel in yesterdayNewUsers and channel in yesterdayMap:				sp = self.survivalProbability(yesterdayNewUsers[channel],yesterdayMap[channel])						#周渠道留存率			#周留存率=本周新增用户数在下一周启动了APP至少1次的用户数/本周新增用户数			#1.取得上上周新增用户			#2.取得上周启动用户			#3.比较 取周留存数			minsp = 0.0			#print channel,(channel in newUsersWeekMap and channel in weekMap)			if channel in newUsersWeekMap and channel in weekMap:				minsp = self.survivalProbability(newUsersWeekMap[channel],weekMap[channel])						#月留存			maxsp = 0.0			#print channel,channel in newUsersWeekMap and channel in weekMap			if channel in newUsersMonthMap and channel in monthMap:				maxsp = self.survivalProbability(newUsersMonthMap[channel],monthMap[channel])			"""			#7日留存率			#周留存率=上一周新增用户数在本周启动了APP至少1次的用户数/上一周新增用户总数			minsp = 0.0			if channel in newUsersWeekMap and channel in weekMap:				minsp = self.survivalProbability(newUsersWeekMap[channel],weekMap[channel])						#30日留存率			#月留存率=上一月新增用户数在本月启动了APP至少1次的用户数/上一月新增用户总数			maxsp = 0.0			if channel in newUsersMonthMap and channel in monthMap:				maxsp = self.survivalProbability(newUsersMonthMap[channel],monthMap[channel])			"""						#昨日卸载用户数(率？)			#uninstall_rate = 0			uninstall_user = 0						#获取活跃的注册用户数(分渠道)			arc = channels[channel]['active_register_count']									try:				self.db.execute(insertSql%(today,channel,new_user,increment_time,startup,use_time,active_user,min_active_user,max_active_user,sp,minsp,maxsp,uninstall_user,3,arc))				xlswriter.writerow([self.curDate, new_user, increment_time, spName[0], spName[1], str(active_user),str(min_active_user)+"%",str(max_active_user)+"%",str(sp)+"%",str(minsp)+"%",str(maxsp)+"%",str(startup),str(int(use_time/startup))], sheet_name=u'渠道信息')								except Exception:								printLog("insert error!")				errorMsg = "入库统计结果数据 错误<br />"				errorMsg += "错误数据：日期=>" + str(today) + " 渠道=>" + str(channel) + " 新增用户数=>" + str(new_user) + " 最多增量时间=>" + str(increment_time) + " 启动次数=>" + str(startup) + " 使用时长=>" + str(use_time) + " 用户活跃数=>" + str(active_user) + " 7天活跃用户=>" + str(min_active_user) + " 30天活跃用户=>" + str(max_active_user) + " 次日留存率=>" + str(sp) + " 7天留存率=>" + str(minsp) + " 30天留存率=>" + str(maxsp) + " 昨日卸载数=>" + str(uninstall_user) + " 应用类型=>" + str(appid)							printLog(errorMsg)				traceback.print_exc()				continue					xlswriter.save()				self.db.close()		#计算留存率	def survivalProbability(self, todayMap = {}, yesterdayMap={}):				live = {}				for device in todayMap:			if device in yesterdayMap:				live[device] = 0				lives = len(live)		today = len(todayMap)		#print lives,today		sp = 0		if today != 0:			sp = round((float(lives) / float(today))*100,2)				return sp				def printLog(src, ts=""):	if ts == "":		ts = ctime()	print ts, src	f.write(ts + " " + str(src) + "\n")	f.flush()if __name__ == '__main__':		path  = os.path.dirname(os.path.abspath(__file__)) 	f = open(path+"/hqeds.log",'w');		usage = "usage: %prog [options] arg1 arg2"	parser = OptionParser(usage = usage, version="%prog 0.1")	parser.add_option("-s", "--skip", help = 'Skip data loading', dest = "skip")	parser.add_option("-d", "--delay", help = 'Delay a number day', dest = "delay")	(options, args) = parser.parse_args()		if len(sys.argv)<=1:		parser.print_help()		sys.exit(2)			skip = options.skip or 0	delay = options.delay or 1		delay = int(delay)		beforeSinal = threading.Event()	before = DailyBeforeUpdateThread(beforeSinal, skip, delay)	before.start()		afterSinal = threading.Event()	ma = QunachiExtractDailySummary(before, path, beforeSinal, afterSinal, delay)	ma.start()		after = DailyAfterUpdateThread(ma, afterSinal, delay)	after.start()
